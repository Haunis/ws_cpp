/**
 *	参考:
 *		https://www.cnblogs.com/qicosmos/p/4283455.html
 * 		https://zhuanlan.zhihu.com/p/97128024
 *
 *	1.左值，右值，将亡值
 *		C++11中所有的值必属于左值、将亡值、纯右值三者之一。
 *		左值: 指既能出现在等号左边也能出现在等号右边的变量(或表达式)
 *			 如：非匿名对象（包括变量）、函数返回的引用、const对象等
 *		纯右值：非引用返回的临时变量(函数的返回值)、运算表达式产生的临时变量、原始字面量和lambda表达式等。
 *			   只能出现在等号右边
 *		将亡值：C++11新增的、与右值引用相关的表达式，比如，将要被移动的对象、T&&函数返回值、
 *			  std::move返回值、转换为T&&的类型的转换函数的返回值等。
 *
 * 		区分左值和右值的一个简单办法是：看能不能对表达式取地址，如果能，则为左值，否则为右值
 *
 * 		从本质上理解，创建和销毁由编译器幕后控制，程序员只能确保在本行代码有效的，就是右值(包括立即数)；
 * 		而用户创建的，通过作用域规则可知其生存期的，就是左值(包括函数返回的局部变量的引用以及const对象)。
 *
 *
 *	2.引用
 *		是给一个存在的对象定义的别名，一个变量可以有多个引用，引用必须初始化.
 *	    引用只能在初始化的时候引用一次，不能更改引用其他变量
 *
 *
 * 	2.1左值引用:
 * 		是对左值的引用
 *		左值引用在汇编层面其实和普通的指针是一样的；定义引用变量必须初始化，因为引用其实就是一个别名，需要告诉编译器定义的是谁的引用。
 * 		&获得左值引用，左值引用只能绑定左值.
 * 		不能将左值引用绑定到一个右值，但是const的左值引用可以，常量引用不能修改绑定对象的值
 * 		可以理解左值引用和它绑定的变量指向同一块内存?
 *
 * 	2.2右值引用:
 * 		对右值的引用就是右值引用，而且右值是匿名变量，我们也只能通过引用的方式来获取右值
 * 		通过&&获得右值引用，右值引用只能绑定右值
 * 		右值引用的作用：
 * 			1.解决临时对象非必要的昂贵的拷贝操作
 * 			2.解决在模板函数中如何按照参数的实际类型进行转发。
 *
 * 		右值引用是c++11新增的,注意添加c++11支持
 *
 * 	提一下常量左引用：fun(const int& num)
 * 		是个“万能”引用，既可以接受左值，也可以接受右值
 * 		在汇编层面右值引用做的事情和常引用是相同的，即产生临时量来存储常量。
 * 		但是，唯一 一点的区别是，右值引用可以进行读写操作，而常引用只能进行读操作。
 *
 * 	3.函数返回左引用：
 * 		参考：https://blog.csdn.net/keyouan2008/article/details/5771844
 * 		不要返回局部变量的引用
 *
 */
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <typeinfo>
using namespace std;

void fun(int &num) // 左值引用作为函数参数，只能传左值
{
	printf("fun left--> &num=%p\n", &num);
	num = num * 2;
}
void fun(int &&num) // 右值引用作为函数参数;和上述fun(int &num)重载
{
	printf("fun right--> &num=%p\n", &num);
	num = num * 2;
}

void fun_common(const int &num) // 可以接收左值,也可以接收右值(传参时右值引用会被转化为const左值引用)
{
	// num = num * 2;//error;常量左引用不可修改值
	printf("fun_common--> num=%d, &num=%p\n", num, &num);
}

int g_temp;
int &fun()
{
	g_temp = 3;
	printf("fun --> g_temp=%d, &g_temp = %p\n", g_temp, &g_temp);
	// return 3; //error,必须返回一个左值
	return g_temp; // 返回全局变量，不要返回局部变量的引用;局部变量会在函数执行完被回收
}

int main()
{
	printf("----------------------1 左值引用：对左值取引用----------------------\n");
	int i = 1;	  // i是左值
	int &l_i = i; // l_i是左值i的引用;可以理解i 和l_i同时指向一个内存,内存里存的是1
	printf("&i = %p,typeid(i).name()=%s \n", &i, typeid(i).name());
	printf("&l_i = %p,typeid(l_i).name=%s \n", &l_i, typeid(l_i).name()); // i和l_i地址和类型都相同

	i = 20;
	printf("i=%d,l_i = %d\n", i, l_i); // 修改i,l_i也会修改(因为指向同一个内存地址)
	l_i = 30;						   // 通过左值引用修改内存的值
	printf("i=%d,l_i = %d\n", i, l_i); // 修改l_i，i也会修改

	printf("\n--------------------2 左值引用：不可对右值取引用----------------------\n");
	//	int &i2 = 10; //error,10是个立即数是在寄存器中存储，不是在内存中，无法进行取地址操作

	// 下面这个是ok的,使用常引用引用常量数字10，因此在内存中产生临时变量保存10，这个变量可以进行取地址操作
	// 相当于进行两步 1.const int temp = 10; 2.const int &var = temp;
	const int &i2 = 10; // 只能通过常引用来读取数据，无法去修改数据

	printf("\n--------------------3. 调用参数为左引用的函数----------------------\n");
	printf("i = %d\n", i); // 30
	fun(i);
	printf("after i = %d\n", i); // 60

	fun_common(i);
	fun_common(8); // fun_common()可以接受左引用，也可以接受右引用

	printf("\n--------------------4.函数返回左引用----------------------\n");
	printf("g_temp=%d, &g_temp=%p \n", g_temp, &g_temp);
	// int ret = fun();//ok,使用新变量ret接收,ret指向新的内存,内存里存储fun()返回的值
	int &ret = fun(); // ret 指向fun()返回的值
	printf("ret=%d, &ret=%p \n", ret, &ret); // ret的地址和g_temp相同
	return 0;
}
