/**
 * @date 2023-07-23
 *
 *  内存模型参考：
 *      https://www.cnblogs.com/zhangsf/p/3835033.html
 *      https://blog.csdn.net/ywcpig/article/details/52303745
 *      https://blog.csdn.net/JACKSONMHLK/article/details/114392343
 *
 *
 *  1.linux程序在内存的分布：
 *	   ———————————
 *	  |   低地址   |
 *	  |   .text   |
 *	  |   .data   |
 *	  |   .bss    |
 *	  |   heap    |  -->堆
 *	  |     ￬     |
 *	  |   unused  |
 *	  |     ￪     |
 *	  |   stack   |  -->栈
 *	  |   env     |
 *	  |   高地址   |
 *	   ———————————
 *     .text   代码段；程序编译后的主体，即程序的机器指令，也就是汇编代码; 如main函数
 *     .data   数据段；静态内存，存储显式初始化的全局变量、静态(全局)变量、常量;  需要占用文件空间，其内容由程序初始化
 *     .bss    存储未初始化或初始化为0的全局变量、静态变量;
 *             具体体现为一个占位符，并不给该段的数据分配空间，只是记录数据所需空间的大小。
 *             不占用.exe文件空间的，其内容由操作系统初始化（清零）
 *     heap    动态内存，如malloc、new申请的内存; 向高地址方向增长
 *     stack   用来进行函数调用；保存函数参数，临时变量，返回地址等
 * 
 *     .rodata  存放只读数据...这个没显示在上图中？
 * 
 *      text、data、bss在编译完成后就存在，heap和stack是在程序运行被加载到内存才存在。
 *
 *  注意：
 *      .data和.bss在加载时合并到一个Segment（Data Segment）中，这个Segment是可读可写的
 * 
 *  2.动态内存分配和静态内存分配
 *    参考： https://blog.csdn.net/zl3090/article/details/105329908/
 *    动态内存：
 *       动态存储方式是指在程序运行期间根据需要进行动态的分配存储空间的方式。特点是按需分配
 *       动态存储变量是在程序执行过程中，使用它时才分配存储单元， 使用完毕立即释放。 
 *       如： new,malloc申请的堆内存，alloca申请的栈内存
 *       
 *    静态内存：
 *       在程序编译或者运行过程中，按事先规定的大小分配内存空间的分配方式，必须事先知道所需内存空间的大小
 *       一定会存在的而且会永恒存在、不会消失，他们在程序编译完成后就已经分配好了，生命周期持续至程序结束
 *       如：局部static变量、全局static变量、全局变量和常量
 *       
 * 
 *    静态分配和动态分配的区别主要是两个：
 *      1. 时间不同: 静态分配发生在程序编译和连接的时候。动态分配则发生在程序调入和执行的时候。
 *      2. 空间不同: 堆都是动态分配的，没有静态分配的堆。
 *                  栈有2种分配方式：
 *                      静态分配: 是编译器完成的，比如局部变量的分配。
 *                      动态分配: 由函数alloca进行分配。不过栈的动态分配是由编译器进行释放，无需手工实现。  
 *      
 *  3.堆和栈的不同
 *      https://blog.csdn.net/qq_43152052/article/details/98889139
 *      1.管理方式不同： 堆由程序员控制，栈由编译器管理
 *      2.空间大小不同： 栈空间很小，VC6下是1M；而32位系统堆可达4G
 *      3.产生碎片不同： 对于堆来说频繁new/delete会造成内存空间不连续，产生内存碎片，影响程序效率
 *                     而栈却无此问题，栈是先进后出的队列，不可能有一个内存块从栈中间弹出，在它弹出之前，在他上面的后进的栈内容已经被弹出
 *      4.生长方向不同： 堆向内存地址增加方向生长，栈向内存地址减小方向生长
 *      5.分配方式不同： 堆都是动态分配的，无静态分配的堆。而栈是有动态分配和静态分配的。
 *      6.分配效率不同： 堆的效率比栈低很多
 *                     堆的分配： 比如先在堆内存中搜索可用的足够大小空间；
 *                              如果空间不够(可能由于内存碎片多)，就有可能调用系统功能去增加程序数据段的内存空间
 *                     栈的分配： 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，
 *                              压栈出栈都有专门的指令执行，这就决定了栈的效率比较高
 *      
 *  4.查看编译后的elf文件变量地址:
 *      nm a.out
 */

#include <stdio.h>
#include <stdlib.h>

class Person
{
public:
    int age;

public:
    Person(int age) : age(age)
    {
    }
};

int a1 = 1; //.data; 声明且定义

int a2;     //.bss;  声明且定义;初始化值为0，所以存储在bss段
int a3 = 0; //.bss;  声明且定义;初始化值为0，所以存储在bss段

extern int a4; // 声明但未定义; 编译时未考虑此变量？

const int a5 = 2; //.rodata段，存放只读数据

char *a6 = "123456789";     //.data
const char *a7 = "abcdefh"; //.data

int a8 [] = {1, 2, 3, 4}; //.data

int *pp = (int *)malloc(sizeof(int) * 4); //.bss段

int main() //.text段
{
    *pp = 7;

    int b1 = 1;

    char sss[] = "abc";     

    Person *person = new Person(18);

    printf("a1=%d, a2=%d, a3=%d\n", a1, a2, a3);
    printf("*pp=%d\n", *pp);
    printf("person age=%d\n", person->age);

    return 0;
}
