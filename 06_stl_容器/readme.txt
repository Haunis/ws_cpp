STL内存优化：
    https://blog.csdn.net/m0_63639164/article/details/129136234
    https://blog.csdn.net/qq_55439426/article/details/127378756
    https://blog.csdn.net/qq_45113223/article/details/128720857
    https://blog.csdn.net/weixin_42853463/article/details/131174067

STL使用二级配置器进行内存管理

一、⼀级配置器：
    分配的是⼤于128字节的空间
    如果分配不成功，调⽤句柄释放⼀部分内存，如果还不能分配成功，抛出异常。

    ⼀级配置器以malloc()，free()，realloc()等C函数执⾏实际的内存配置、释放、重新配置等操作，并且能在内存
    需求不被满⾜的时候，调⽤⼀个指定的函数。

    ⼀级配置器只是对malloc函数和free函数的简单封装，在allocate内调⽤malloc，在deallocate内调⽤free。
    同时，⼀级配置器的oom_malloc函数，⽤来处理malloc失败的情况

二、⼆级配置器:
    分配的是小于128字节的空间

    1.二级配置器是为了解决一级配置器的问题：
        1.内存分配/释放的效率低
        2.当配置⼤量的⼩内存块时，会导致内存碎⽚⽐较严重
        3.配置内存时，需要额外的部分空间存储内存块信息，所以配置⼤量的⼩内存块时，还会导致额外内存负担

    2.配置器里的数据结构：
        1.自由链表数组(free_list): 就是一个数组，大小为16，每个元素是一个指针，指向一个链表
        2.链表：obj*类型，每个节点对应一个内存块
        3.内存池：start_free、end_free和heap_size维护内存池。
                 内存池是提前开辟好的128字节空间，其中start_free和end_free指针指向内存的头和尾。

    3.内存分配：
        allocate函数内先判断要分配的内存⼤⼩，若⼤于128字节，直接调⽤第⼀级配置器。
        若小于128字节，则根据要分配的内存⼤⼩从16个链表中选出⼀个链表，取出该链表的第⼀个节点。
        若相应的链表为空，则调⽤refill函数填充该链表。默认是填充20个数据块。

    4.链表填充过程：
        若allocate函数内要取出节点的链表为空，则会调⽤refill函数填充该链表。
        当refill函数要填充链表时，就会调⽤chunk_alloc函数，从内存池取出相应的内存。
        chunk_alloc函数内⾸先判断内存池⼤⼩是否⾜够填充⼀个有20个节点的链表:
        1).若内存池⾜够⼤，则直接返回20个内存节点⼤⼩的内存块给refill；
            
        2).若内存池⼤⼩⽆法满⾜20个内存节点的⼤⼩，但⾄少满⾜1个内存节点，则直接返回相应的内存节点⼤⼩的内存块给refill；

        3).若内存池连1个内存节点⼤⼩的内存块都⽆法提供，则chunk_alloc函数会将内存池中那⼀点点的内存⼤⼩分配给其他合适的链表，
           然后去调⽤malloc函数分配的内存⼤⼩为所需的两倍。
           若malloc成功，则返回相应的内存⼤⼩给refill；
           若malloc失败，会先搜寻其他链表的可⽤的内存块，添加到内存池，然后递归调⽤chunk_alloc函数来分配内存，
           若其他链表也⽆内存块可⽤，则只能调⽤第⼀级空间配置器。

        填充调用链： allocate --> refill --> chunk_alloc --> malloc
        寻找过程：   链表节点 --> 内存池申请 --> malloc堆内存申请 --> 链表数组后面大的链表节点